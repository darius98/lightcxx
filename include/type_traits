#ifndef __LIGHTCXX_GUARD_TYPE_TRAITS
#define __LIGHTCXX_GUARD_TYPE_TRAITS

#include <__lightcxx/__declval.h>

namespace std {

using size_t = decltype(sizeof(void*));
using nullptr_t = decltype(nullptr);

// region [meta.help]

template<class _T, _T _V>
struct integral_constant {
    static constexpr _T value = _V;

    using value_type = _T;

    using type = integral_constant<_T, _V>;

    constexpr operator value_type() const noexcept {
        return value;
    }

    constexpr value_type operator()() const noexcept {
        return value;
    }
};

template<bool _B>
using bool_constant = integral_constant<bool, _B>;

using true_type = bool_constant<true>;

using false_type = bool_constant<false>;

// endregion

// region implementation-details

namespace _Light {

struct _No_t {};

template<class _T>
consteval bool __dependent_false() {
    return false;
}

}  // namespace _Light

#define __UNARY_TRAIT_TRUE_FOR_ALL_CV(_Trait, _T)                                                  \
    template<>                                                                                     \
    struct _Trait<_T> : ::std::true_type {};                                                       \
    template<>                                                                                     \
    struct _Trait<_T const> : ::std::true_type {};                                                 \
    template<>                                                                                     \
    struct _Trait<_T volatile> : ::std::true_type {};                                              \
    template<>                                                                                     \
    struct _Trait<_T const volatile> : ::std::true_type {}

#ifdef _LIGHTCXX_DONT_USE_BUILTINS
#define __LIGHTCXX_USE_BUILTIN(_B) 0
#else
#define __LIGHTCXX_USE_BUILTIN(_B) (defined(_B) || (defined(__has_builtin) && __has_builtin(_B)))
#endif

// endregion

// region [meta.unary.cat]

// region is_void
#if __LIGHTCXX_USE_BUILTIN(__is_void)

template<class _T>
struct is_void : bool_constant<__is_void(_T)> {};

template<class _T>
constexpr bool is_void_v = __is_void(_T);

#else

template<class _T>
struct is_void : false_type {};

__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_void, void);

template<class _T>
constexpr bool is_void_v = is_void<_T>::value;

#endif  // endregion

// region is_null_pointer
template<class _T>
struct is_null_pointer : false_type {};

__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_null_pointer, nullptr_t);

template<class _T>
constexpr bool is_null_pointer_v = is_null_pointer<_T>::value;
// endregion

// region is_integral
#if __LIGHTCXX_USE_BUILTIN(__is_integral)

template<class _T>
struct is_integral : bool_constant<__is_integral(_T)> {};

template<class _T>
constexpr bool is_integral_v = __is_integral(_T);

#else

template<class _T>
struct is_integral : false_type {};

__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, bool);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, char);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, wchar_t);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, char8_t);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, char16_t);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, char32_t);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, signed char);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, short);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, int);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, long int);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, long long int);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, unsigned char);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, unsigned short int);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, unsigned int);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, unsigned long int);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, unsigned long long int);

template<class _T>
constexpr bool is_integral_v = is_integral<_T>::value;

#endif  // endregion

// region is_floating_point
#if __LIGHTCXX_USE_BUILTIN(__is_floating_point)

template<class _T>
struct is_floating_point : bool_constant<__is_floating_point(_T)> {};

template<class _T>
constexpr bool is_floating_point_v = __is_floating_point(_T);

#else

template<class _T>
struct is_floating_point : false_type {};

__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_floating_point, float);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_floating_point, double);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_floating_point, long double);

template<class _T>
constexpr bool is_floating_point_v = is_floating_point<_T>::value;

#endif  // endregion

// region is_array
#if __LIGHTCXX_USE_BUILTIN(__is_array)

template<class _T>
struct is_array : bool_constant<__is_array(_T)> {};

template<class _T>
constexpr bool is_array_v = __is_array(_T);

#else

template<class _T>
struct is_array : false_type {};

template<class _T>
struct is_array<_T[]> : true_type {};

template<class _T, size_t _N>
struct is_array<_T[_N]> : true_type {};

template<class _T>
constexpr bool is_array_v = is_array<_T>::value;

#endif  // endregion

// region is_pointer
#if __LIGHTCXX_USE_BUILTIN(__is_pointer)

template<class _T>
struct is_pointer : bool_constant<__is_pointer(_T)> {};

template<class _T>
constexpr bool is_pointer_v = __is_pointer(_T);

#else

template<class _T>
struct is_pointer : false_type {};

template<class _T>
struct is_pointer<_T*> : true_type {};

template<class _T>
struct is_pointer<_T* const> : true_type {};

template<class _T>
struct is_pointer<_T* volatile> : true_type {};

template<class _T>
struct is_pointer<_T* const volatile> : true_type {};

template<class _T>
constexpr bool is_pointer_v = is_pointer<_T>::value;

#endif  // endregion

// region is_lvalue_reference
#if __LIGHTCXX_USE_BUILTIN(__is_lvalue_reference)

template<class _T>
struct is_lvalue_reference : bool_constant<__is_lvalue_reference(_T)> {};

template<class _T>
constexpr bool is_lvalue_reference_v = __is_lvalue_reference(_T);

#else

template<class _T>
struct is_lvalue_reference : false_type {};

template<class _T>
struct is_lvalue_reference<_T&> : true_type {};

template<class _T>
constexpr bool is_lvalue_reference_v = is_lvalue_reference<_T>::value;

#endif  // endregion

// region is_rvalue_reference
#if __LIGHTCXX_USE_BUILTIN(__is_rvalue_reference)

template<class _T>
struct is_rvalue_reference : bool_constant<__is_rvalue_reference(_T)> {};

template<class _T>
constexpr bool is_rvalue_reference_v = __is_rvalue_reference(_T);

#else

template<class _T>
struct is_rvalue_reference : false_type {};

template<class _T>
struct is_rvalue_reference<_T&&> : true_type {};

template<class _T>
constexpr bool is_rvalue_reference_v = is_rvalue_reference<_T>::value;

#endif  // endregion

// region is_function
#if __LIGHTCXX_USE_BUILTIN(__is_function)

template<class _T>
struct is_function : bool_constant<__is_function(_T)> {};

template<class _T>
constexpr bool is_function_v = __is_function(_T);

#else

// Forward declare is_const
template<class _T>
struct is_const;

template<class _T>
constexpr bool is_function_v
  = !is_const<const _T>::value && !is_lvalue_reference_v<_T> && !is_rvalue_reference_v<_T>;

template<class _T>
struct is_function : bool_constant<is_function_v<_T>> {};

#endif  // endregion

// region is_member_object_pointer
#if __LIGHTCXX_USE_BUILTIN(__is_member_object_pointer)

template<class _T>
struct is_member_object_pointer : bool_constant<__is_member_object_pointer(_T)> {};

template<class _T>
constexpr bool is_member_object_pointer_v = __is_member_object_pointer(_T);

#else

template<class _T>
struct is_member_object_pointer : false_type {};

template<class _T, class _U>
struct is_member_object_pointer<_T _U::*> : bool_constant<!is_function_v<_T>> {};

template<class _T, class _U>
struct is_member_object_pointer<_T _U::*const> : bool_constant<!is_function_v<_T>> {};

template<class _T, class _U>
struct is_member_object_pointer<_T _U::*volatile> : bool_constant<!is_function_v<_T>> {};

template<class _T, class _U>
struct is_member_object_pointer<_T _U::*const volatile> : bool_constant<!is_function_v<_T>> {};

template<class _T>
constexpr bool is_member_object_pointer_v = is_member_object_pointer<_T>::value;

#endif  // endregion

// region is_member_function_pointer
#if __LIGHTCXX_USE_BUILTIN(__is_member_function_pointer)

template<class _T>
struct is_member_function_pointer : bool_constant<__is_member_function_pointer(_T)> {};

template<class _T>
constexpr bool is_member_function_pointer_v = __is_member_function_pointer(_T);

#else

template<class _T>
struct is_member_function_pointer : false_type {};

template<class _T, class _U>
struct is_member_function_pointer<_T _U::*> : bool_constant<is_function_v<_T>> {};

template<class _T, class _U>
struct is_member_function_pointer<_T _U::*const> : bool_constant<is_function_v<_T>> {};

template<class _T, class _U>
struct is_member_function_pointer<_T _U::*volatile> : bool_constant<is_function_v<_T>> {};

template<class _T, class _U>
struct is_member_function_pointer<_T _U::*const volatile> : bool_constant<is_function_v<_T>> {};

template<class _T>
constexpr bool is_member_function_pointer_v = is_member_function_pointer<_T>::value;

#endif  // endregion

// region is_enum
#if __LIGHTCXX_USE_BUILTIN(__is_enum)

template<class _T>
struct is_enum : bool_constant<__is_enum(_T)> {};

template<class _T>
constexpr bool is_enum_v = __is_enum(_T);

#else

template<class _T>
struct is_enum {
    static_assert(_Light::__dependent_false<_T>(), "is_enum is not supported on this compiler.");
};

template<class _T>
constexpr bool is_enum_v = is_enum<_T>::value;

#endif  // endregion

// region is_union
#if __LIGHTCXX_USE_BUILTIN(__is_union)

template<class _T>
struct is_union : bool_constant<__is_union(_T)> {};

template<class _T>
constexpr bool is_union_v = __is_union(_T);

#else

template<class _T>
struct is_union {
    static_assert(_Light::__dependent_false<_T>(), "is_union is not supported on this compiler.");
};

template<class _T>
constexpr bool is_union_v = is_union<_T>::value;

#endif  // endregion

// region is_class
#if __LIGHTCXX_USE_BUILTIN(__is_class)

template<class _T>
struct is_class : bool_constant<__is_class(_T)> {};

template<class _T>
constexpr bool is_class_v = __is_class(_T);

#else

template<class _T>
struct is_class {
    static_assert(_Light::__dependent_false<_T>(), "is_class is not supported on this compiler.");
};

template<class _T>
constexpr bool is_class_v = is_class<_T>::value;

#endif  // endregion

// endregion

// region [meta.unary.comp]

// region is_reference
#if __LIGHTCXX_USE_BUILTIN(__is_reference)

template<class _T>
struct is_reference : bool_constant<__is_reference(_T)> {};

template<class _T>
constexpr bool is_reference_v = __is_reference(_T);

#else

template<class _T>
struct is_reference : false_type {};

template<class _T>
struct is_reference<_T&> : true_type {};

template<class _T>
struct is_reference<_T&&> : true_type {};

template<class _T>
constexpr bool is_reference_v = is_reference<_T>::value;

#endif  // endregion

// region is_arithmetic
#if __LIGHTCXX_USE_BUILTIN(__is_arithmetic)

template<class _T>
struct is_arithmetic : bool_constant<__is_arithmetic(_T)> {};

template<class _T>
constexpr bool is_arithmetic_v = __is_arithmetic(_T);

#else

template<class _T>
constexpr bool is_arithmetic_v = is_integral_v<_T> || is_floating_point_v<_T>;

template<class _T>
struct is_arithmetic : bool_constant<is_arithmetic_v<_T>> {};

#endif  // endregion

// region is_fundamental
#if __LIGHTCXX_USE_BUILTIN(__is_fundamental)

template<class _T>
struct is_fundamental : bool_constant<__is_fundamental(_T)> {};

template<class _T>
constexpr bool is_fundamental_v = __is_fundamental(_T);

#else

template<class _T>
constexpr bool is_fundamental_v
  = is_void_v<_T> || is_null_pointer_v<_T> || is_integral_v<_T> || is_floating_point_v<_T>;

template<class _T>
struct is_fundamental : bool_constant<is_fundamental_v<_T>> {};

#endif  // endregion

// region is_object
#if __LIGHTCXX_USE_BUILTIN(__is_object)

template<class _T>
struct is_object : bool_constant<__is_object(_T)> {};

template<class _T>
constexpr bool is_object_v = __is_object(_T);

#else

template<class _T>
constexpr bool is_object_v
  = is_null_pointer_v<
      _T> || is_integral_v<_T> || is_floating_point_v<_T> || is_enum_v<_T> || is_pointer_v<_T> || is_member_object_pointer_v<_T> || is_member_function_pointer_v<_T> || is_array_v<_T> || is_union_v<_T> || is_class_v<_T>;

template<class _T>
struct is_object : bool_constant<is_object_v<_T>> {};

#endif  // endregion

// region is_scalar
#if __LIGHTCXX_USE_BUILTIN(__is_scalar)

template<class _T>
struct is_scalar : bool_constant<__is_scalar(_T)> {};

template<class _T>
constexpr bool is_scalar_v = __is_scalar(_T);

#else

template<class _T>
constexpr bool is_scalar_v
  = is_null_pointer_v<
      _T> || is_integral_v<_T> || is_floating_point_v<_T> || is_enum_v<_T> || is_pointer_v<_T> || is_member_object_pointer_v<_T> || is_member_function_pointer_v<_T>;

template<class _T>
struct is_scalar : bool_constant<is_scalar_v<_T>> {};

#endif  // endregion

// region is_compound
#if __LIGHTCXX_USE_BUILTIN(__is_compound)

template<class _T>
struct is_compound : bool_constant<__is_compound(_T)> {};

template<class _T>
constexpr bool is_compound_v = __is_compound(_T);

#else

template<class _T>
struct is_compound : bool_constant<!is_fundamental_v<_T>> {};

template<class _T>
constexpr bool is_compound_v = !is_fundamental_v<_T>;

#endif  // endregion

// region is_member_pointer
#if __LIGHTCXX_USE_BUILTIN(__is_member_pointer)

template<class _T>
struct is_member_pointer : bool_constant<__is_member_pointer(_T)> {};

template<class _T>
constexpr bool is_member_pointer_v = __is_member_pointer(_T);

#else

template<class _T>
struct is_member_pointer
        : bool_constant<is_member_object_pointer_v<_T> || is_member_function_pointer_v<_T>> {};

template<class _T>
using is_member_pointer_t
  = bool_constant<is_member_object_pointer_v<_T> || is_member_function_pointer_v<_T>>;

template<class _T>
constexpr bool is_member_pointer_v
  = is_member_object_pointer_v<_T> || is_member_function_pointer_v<_T>;

#endif  // endregion

// endregion

// region [meta.unary.prop]

// region is_const
#if __LIGHTCXX_USE_BUILTIN(__is_const)

template<class _T>
struct is_const : bool_constant<__is_const(_T)> {};

template<class _T>
constexpr bool is_const_v = __is_const(_T);

#else

template<class _T>
struct is_const : false_type {};

template<class _T>
struct is_const<_T const> : true_type {};

template<class _T>
constexpr bool is_const_v = is_const<_T>::value;

#endif  // endregion

// region is_volatile
#if __LIGHTCXX_USE_BUILTIN(__is_volatile)

template<class _T>
struct is_volatile : bool_constant<__is_volatile(_T)> {};

template<class _T>
constexpr bool is_volatile_v = __is_volatile(_T);

#else

template<class _T>
struct is_volatile : false_type {};

template<class _T>
struct is_volatile<_T volatile> : true_type {};

template<class _T>
constexpr bool is_volatile_v = is_volatile<_T>::value;

#endif  // endregion

// region is_constructible
#if __LIGHTCXX_USE_BUILTIN(__is_constructible)

template<class _T, class... _Args>
struct is_constructible : bool_constant<__is_constructible(_T, _Args...)> {};

template<class _T, class... _Args>
constexpr bool is_constructible_v = __is_constructible(_T, _Args...);

#else

template<class _T, class _U>
struct is_same;

template<class _T>
struct remove_cv;

template<class _T>
struct add_pointer;

namespace _Light {

template<class _T, class... _Args>
auto _IsConstructibleTest(int) -> decltype(new _T(declval<_Args>()...));

template<class, class...>
auto _IsConstructibleTest(...) -> _No_t;

template<class _X, class _Y>
auto _IsConstructibleReferenceTest(int) -> decltype(static_cast<_X>(declval<_Y>()));

template<class, class>
auto _IsConstructibleReferenceTest(...) -> _No_t;

template<class _T, class... _Args>
constexpr bool _IsConstructibleImpl
  = is_same<decltype(_IsConstructibleTest<_T, _Args...>(0)), typename add_pointer<_T>::type>::value;

template<class _T, class _From>
constexpr bool _IsConstructibleImpl<_T&, _From> = !is_same<
  decltype(_IsConstructibleReferenceTest<_T&, _From>(0)), _No_t>::value;

template<class _T, class _From>
constexpr bool _IsConstructibleImpl<_T&&, _From> = !is_same<
  decltype(_IsConstructibleReferenceTest<_T&&, _From>(0)), _No_t>::value;

template<class _T, class _From>
constexpr bool _IsConstructibleImpl<_T&&, _From&> = is_same<
  typename remove_cv<_T>::type, typename remove_cv<_From>::type>::value&& is_function_v<_T>;

template<class _T, size_t _N>
constexpr bool _IsConstructibleImpl<_T[_N]> = _IsConstructibleImpl<_T>;

}  // namespace _Light

template<class _T, class... _Args>
struct is_constructible : bool_constant<_Light::_IsConstructibleImpl<_T, _Args...>> {};

template<class _T, class... _Args>
constexpr bool is_constructible_v = _Light::_IsConstructibleImpl<_T, _Args...>;

#endif  // endregion

// region is_default_constructible

template<class _T>
struct is_default_constructible : bool_constant<is_constructible_v<_T>> {};

template<class _T>
constexpr bool is_default_constructible_v = is_constructible_v<_T>;

// endregion

// region is_copy_constructible

template<class _T>
struct add_lvalue_reference;

template<class _T>
struct add_const;

template<class _T>
struct is_copy_constructible
        : bool_constant<is_constructible_v<
            _T, typename add_lvalue_reference<typename add_const<_T>::type>::type>> {};

template<class _T>
constexpr bool is_copy_constructible_v
  = is_constructible_v<_T, typename add_lvalue_reference<typename add_const<_T>::type>::type>;

// endregion

// region is_move_constructible

template<class _T>
struct add_rvalue_reference;

template<class _T>
struct is_move_constructible
        : bool_constant<is_constructible_v<_T, typename add_rvalue_reference<_T>::type>> {};

template<class _T>
constexpr bool is_move_constructible_v
  = is_constructible_v<_T, typename add_rvalue_reference<_T>::type>;

// endregion

// endregion

template<class _T, class _U>
struct [[maybe_unused]] is_same : false_type {};

template<class _T>
struct [[maybe_unused]] is_same<_T, _T> : true_type {};

template<class _T, class _U>
constexpr bool is_same_v = is_same<_T, _U>::value;

namespace _Light {

template<class _T>
auto __is_referenceable_test(int) -> _T&;

template<class>
auto __is_referenceable_test(...) -> _No_t;

template<class _T>
struct __is_referenceable
        : integral_constant<bool, !is_same_v<decltype(__is_referenceable_test<_T>(0)), _No_t>> {};

}  // namespace _Light

template<bool _B, class _T, class _F>
struct conditional {
    using type = _T;
};

template<class _T, class _F>
struct conditional<false, _T, _F> {
    using type = _F;
};

template<bool _B, class _T, class _F>
using conditional_t = typename conditional<_B, _T, _F>::type;

template<class _T>
struct remove_reference {
    using type = _T;
};

template<class _T>
struct remove_reference<_T&> {
    using type = _T;
};

template<class _T>
struct remove_reference<_T&&> {
    using type = _T;
};

template<class _T>
using remove_reference_t = typename remove_reference<_T>::type;

template<class _T>
struct remove_cv {
    using type = _T;
};

template<class _T>
struct remove_cv<const _T> {
    using type = _T;
};

template<class _T>
struct remove_cv<volatile _T> {
    using type = _T;
};

template<class _T>
struct remove_cv<const volatile _T> {
    using type = _T;
};

template<class _T>
using remove_cv_t = typename remove_cv<_T>::type;

template<class _T>
struct add_cv {
    using type = const volatile _T;
};

template<class _T>
using add_cv_t = typename add_cv<_T>::type;

template<class T>
struct add_const {
    using type = const T;
};

template<class _T>
using add_const_t = typename add_const<_T>::type;

template<class T>
struct add_volatile {
    using type = volatile T;
};

template<class _T>
using add_volatile_t = typename add_volatile<_T>::type;

template<class _T>
struct remove_extent {
    using type = _T;
};

template<class _T>
struct remove_extent<_T[]> {
    using type = _T;
};

template<class _T, size_t _N>
struct remove_extent<_T[_N]> {
    using type = _T;
};

template<class _T>
using remove_extent_t = typename remove_extent<_T>::type;

template<class _T>
struct remove_all_extents {
    using type = _T;
};

template<class _T>
struct remove_all_extents<_T[]> {
    using type = typename remove_all_extents<_T>::type;
};

template<class _T, size_t _N>
struct remove_all_extents<_T[_N]> {
    using type = typename remove_all_extents<_T>::type;
};

template<class _T>
using remove_all_extents_t = typename remove_all_extents<_T>::type;

template<class _T>
struct is_polymorphic : bool_constant<__is_polymorphic(_T)> {};

template<class _T>
constexpr bool is_polymorphic_v = is_polymorphic<_T>::value;

template<class _T>
struct is_final : bool_constant<__is_final(_T)> {};

template<class _T>
constexpr bool is_final_v = is_final<_T>::value;

template<class _T>
struct add_lvalue_reference {
  private:
    template<class _U>
    requires(_Light::__is_referenceable<_U>::value) static auto __test() -> remove_reference_t<_U>&;

    template<class _U>
    requires(!_Light::__is_referenceable<_U>::value) static auto __test() -> _U;

  public:
    using type = decltype(__test<_T>());
};

template<class _T>
using add_lvalue_reference_t = typename add_lvalue_reference<_T>::type;

template<class _T>
struct add_rvalue_reference {
  private:
    template<class _U>
    requires(_Light::__is_referenceable<_U>::value) static remove_reference_t<_U>&& __test();

    template<class _U>
    requires(!_Light::__is_referenceable<_U>::value) static _U __test();

  public:
    using type = decltype(__test<_T>());
};

template<class _T>
using add_rvalue_reference_t = typename add_rvalue_reference<_T>::type;

template<class _Base, class _Derived>
struct is_base_of : bool_constant<__is_base_of(_Base, _Derived)> {};

template<class _Base, class _Derived>
constexpr bool is_base_of_v = is_base_of<_Base, _Derived>::value;

template<class _From, class _To>
struct is_convertible : bool_constant<__is_convertible(_From, _To)> {};

template<class _From, class _To>
constexpr bool is_convertible_v = is_convertible<_From, _To>::value;

template<class _T>
struct add_pointer {
  private:
    template<class _U>
    requires(_Light::__is_referenceable<_U>::value
             || is_same_v<remove_cv_t<_U>, void>) static remove_reference_t<_U>* __test();

    template<class _U>
    requires(!_Light::__is_referenceable<_U>::value && !is_same_v<remove_cv_t<_U>, void>) static _U
      __test();

  public:
    using type = decltype(__test<_T>());
};

template<class _T>
using add_pointer_t = typename add_pointer<_T>::type;

template<class _T>
struct decay {
  private:
    using _U = remove_reference_t<_T>;

  public:
    using type
      = conditional_t<is_array_v<_U>, remove_extent_t<_U>*,
                      conditional_t<is_function_v<_U>, add_pointer_t<_U>, remove_cv_t<_U>>>;
};

template<class _T>
using decay_t = typename decay<_T>::type;

}  // namespace std

#undef __UNARY_TRAIT_TRUE_FOR_ALL_CV
#undef __LIGHTCXX_USE_BUILTIN

#endif
